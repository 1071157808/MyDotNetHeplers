这节课需要自己看书
一：锁机制
1. .net锁机制太多了
   时间锁，信号量，互斥锁，读写锁，互锁，易变构造
分类：
<1>  用户模式锁  【就是通过一些cpu指令或者一个死循环】在达到thread等待和休眠
<2>  内核模式锁
就是调用win32底层的代码，来实现thread的各种操作 Thread.Sleep
<3>  混合锁
用户模式 + 内核模式 【场景是最多的】  xxxslim
2. 为什么要用锁
   多个线程对一个“共享资源”进行操作的时候，容易出问题。。。 共享资源混乱
3.用户模式锁
《1》易变结构： 一个线程读，一个写，在release的某种情况下，会有debug。。。
Thread.MemoryBarrier ,  VolatileRead
 volatile关键字作用：
1.不可以对底层代码进行优化。。。
2.我的read和write都是从memrory内存中读取，不是从CPU缓存中读
【我读取的都是最新的】
《2》互锁结构： Interlocked  【只能做一些简单类型的计算】
    Increment：自增操作
    Decrement：自减操作
    Add：增加指定的值
    Exchange： 赋值
    CompareExchange： 比较赋值
《3》旋转锁（自旋锁）：SpinLock
特殊的业务逻辑让thread在用户模式下进行自旋，欺骗cpu当前thread正在运行中

能留在用户模式，就留在用户模式
用户模式 -> 内核模式 -> 用户模式 -> 内核模式  循环，如果走到内核模式会有一些消耗

数据递增

自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，
调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。
其作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，
所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它也有些不足之处：
1、自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，
所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。
2、在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，
调用有些其他函数也可能造成死锁，如 copy_to_user()、copy_from_user()、kmalloc()等。






